// ========================================
// REBECA - SERVI√áO DE GEOCODING
// VERS√ÉO ULTRA PRECISA
// Converte endere√ßo ‚Üí coordenadas (lat/lng)
// Usa Nominatim (OpenStreetMap) - GRATUITO
// ========================================

const https = require('https');
const http = require('http');

const GeocodingService = {

  // Configura√ß√µes
  cidadePadrao: process.env.CIDADE_PADRAO || 'Guai√ßara, SP',
  estadoPadrao: process.env.ESTADO_PADRAO || 'S√£o Paulo',
  paisPadrao: 'Brazil',
  
  // Timeout e retry
  TIMEOUT_MS: 15000,
  MAX_TENTATIVAS: 3,
  DELAY_ENTRE_TENTATIVAS: 1000,

  /**
   * Converte endere√ßo em coordenadas (VERS√ÉO ULTRA PRECISA)
   * M√∫ltiplas tentativas e varia√ß√µes
   */
  async geocodificar(endereco) {
    try {
      if (!endereco || endereco.length < 3) {
        console.log('‚ö†Ô∏è Endere√ßo muito curto para geocodificar');
        return null;
      }

      console.log(`\nüåç === GEOCODING ULTRA PRECISO ===`);
      console.log(`üìù Entrada: "${endereco}"`);

      // Limpar e preparar endere√ßo
      let enderecoLimpo = this.limparEndereco(endereco);
      console.log(`üßπ Limpo: "${enderecoLimpo}"`);
      
      // Se n√£o tem cidade, adicionar cidade padr√£o
      const temCidade = this.temCidade(enderecoLimpo);
      if (!temCidade) {
        enderecoLimpo = `${enderecoLimpo}, ${this.cidadePadrao}`;
        console.log(`üìç Com cidade: "${enderecoLimpo}"`);
      }

      // Tentar m√∫ltiplas varia√ß√µes em ordem de precis√£o
      const variacoes = this.gerarVariacoes(endereco, enderecoLimpo);
      
      for (let i = 0; i < variacoes.length; i++) {
        const variacao = variacoes[i];
        console.log(`\nüîç Tentativa ${i + 1}/${variacoes.length}: "${variacao}"`);
        
        const resultado = await this.buscarComRetry(variacao);
        
        if (resultado) {
          // Validar resultado (est√° na regi√£o esperada?)
          if (this.validarResultado(resultado)) {
            console.log(`‚úÖ ENCONTRADO: ${resultado.enderecoFormatado}`);
            console.log(`   üìç Coordenadas: ${resultado.latitude.toFixed(7)}, ${resultado.longitude.toFixed(7)}`);
            console.log(`   üéØ Confian√ßa: ${resultado.confianca || 'm√©dia'}`);
            return resultado;
          } else {
            console.log(`‚ö†Ô∏è Resultado fora da regi√£o esperada, tentando pr√≥xima varia√ß√£o...`);
          }
        }
      }

      console.log('‚ùå Endere√ßo n√£o encontrado em nenhuma tentativa');
      return null;

    } catch (error) {
      console.error('‚ùå Erro no geocoding:', error.message);
      return null;
    }
  },

  /**
   * Gerar varia√ß√µes do endere√ßo para m√∫ltiplas tentativas
   */
  gerarVariacoes(original, limpo) {
    const variacoes = [];
    
    // 1. Endere√ßo limpo completo
    variacoes.push(limpo);
    
    // 2. Com estado expl√≠cito
    if (!limpo.toLowerCase().includes(this.estadoPadrao.toLowerCase())) {
      variacoes.push(`${limpo}, ${this.estadoPadrao}`);
    }
    
    // 3. Com pa√≠s
    variacoes.push(`${limpo}, ${this.paisPadrao}`);
    
    // 4. Original com cidade
    if (!this.temCidade(original)) {
      variacoes.push(`${original}, ${this.cidadePadrao}, ${this.estadoPadrao}`);
    }
    
    // 5. Sem n√∫mero (√†s vezes ajuda)
    const semNumero = limpo.replace(/,?\s*\d+\s*/, ' ').trim();
    if (semNumero !== limpo) {
      variacoes.push(`${semNumero}, ${this.cidadePadrao}`);
    }
    
    // 6. Formato estruturado
    const partes = limpo.split(',').map(p => p.trim());
    if (partes.length >= 2) {
      variacoes.push(`${partes[0]}, ${this.cidadePadrao}, ${this.estadoPadrao}, Brasil`);
    }
    
    // Remover duplicatas mantendo ordem
    return [...new Set(variacoes)];
  },

  /**
   * Busca com retry autom√°tico
   */
  async buscarComRetry(endereco, tentativa = 1) {
    try {
      const resultado = await this.buscarNominatim(endereco);
      
      if (resultado) {
        return resultado;
      }
      
      // Retry se ainda tem tentativas
      if (tentativa < this.MAX_TENTATIVAS) {
        console.log(`   ‚è≥ Tentativa ${tentativa} falhou, aguardando retry...`);
        await this.sleep(this.DELAY_ENTRE_TENTATIVAS);
        return this.buscarComRetry(endereco, tentativa + 1);
      }
      
      return null;
    } catch (e) {
      if (tentativa < this.MAX_TENTATIVAS) {
        await this.sleep(this.DELAY_ENTRE_TENTATIVAS);
        return this.buscarComRetry(endereco, tentativa + 1);
      }
      return null;
    }
  },

  /**
   * Validar se resultado est√° na regi√£o esperada
   */
  validarResultado(resultado) {
    if (!resultado || !resultado.latitude || !resultado.longitude) {
      return false;
    }
    
    // Validar se est√° no Brasil (aproximadamente)
    const latMin = -33.7, latMax = 5.3;   // Brasil
    const lonMin = -73.9, lonMax = -34.8;
    
    const lat = resultado.latitude;
    const lon = resultado.longitude;
    
    if (lat < latMin || lat > latMax || lon < lonMin || lon > lonMax) {
      console.log(`   ‚ö†Ô∏è Coordenadas fora do Brasil: ${lat}, ${lon}`);
      return false;
    }
    
    // Se temos cidade esperada, validar proximidade
    // (opcional - pode ser expandido)
    
    return true;
  },

  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  },

  /**
   * Busca no Nominatim (OpenStreetMap) - VERS√ÉO MELHORADA
   */
  async buscarNominatim(endereco) {
    return new Promise((resolve) => {
      const query = encodeURIComponent(endereco);
      const url = `https://nominatim.openstreetmap.org/search?q=${query}&format=json&limit=3&countrycodes=br&addressdetails=1`;

      const options = {
        headers: {
          'User-Agent': 'Rebeca-WhatsApp-Bot/2.0 (contato@ubmax.com.br)',
          'Accept-Language': 'pt-BR,pt;q=0.9',
          'Accept': 'application/json',
        },
        timeout: this.TIMEOUT_MS,
      };

      const req = https.get(url, options, (res) => {
        let data = '';

        res.on('data', chunk => data += chunk);
        
        res.on('end', () => {
          try {
            const results = JSON.parse(data);
            
            if (results && results.length > 0) {
              // Pegar o resultado mais relevante
              const r = this.selecionarMelhorResultado(results);
              
              if (r) {
                resolve({
                  latitude: parseFloat(r.lat),
                  longitude: parseFloat(r.lon),
                  enderecoFormatado: r.display_name,
                  enderecoSimplificado: this.simplificarEndereco(r),
                  bairro: r.address?.suburb || r.address?.neighbourhood,
                  cidade: r.address?.city || r.address?.town || r.address?.village,
                  estado: r.address?.state,
                  cep: r.address?.postcode,
                  tipo: r.type,
                  classe: r.class,
                  importancia: parseFloat(r.importance || 0),
                  confianca: this.calcularConfianca(r)
                });
              } else {
                resolve(null);
              }
            } else {
              resolve(null);
            }
          } catch (e) {
            console.error('   ‚ùå Erro parsing Nominatim:', e.message);
            resolve(null);
          }
        });

      });
      
      req.on('error', (err) => {
        console.error('   ‚ùå Erro requisi√ß√£o Nominatim:', err.message);
        resolve(null);
      });
      
      req.on('timeout', () => {
        console.error('   ‚ùå Timeout Nominatim');
        req.destroy();
        resolve(null);
      });
    });
  },

  /**
   * Selecionar melhor resultado de m√∫ltiplos
   */
  selecionarMelhorResultado(results) {
    if (!results || results.length === 0) return null;
    if (results.length === 1) return results[0];
    
    // Priorizar por tipo
    const prioridades = ['house', 'building', 'shop', 'amenity', 'road', 'neighbourhood'];
    
    for (const tipo of prioridades) {
      const resultado = results.find(r => r.type === tipo);
      if (resultado) return resultado;
    }
    
    // Ordenar por import√¢ncia
    const ordenados = results.sort((a, b) => 
      parseFloat(b.importance || 0) - parseFloat(a.importance || 0)
    );
    
    return ordenados[0];
  },

  /**
   * Calcular confian√ßa do resultado
   */
  calcularConfianca(resultado) {
    const importancia = parseFloat(resultado.importance || 0);
    
    if (importancia > 0.8) return 'alta';
    if (importancia > 0.5) return 'm√©dia-alta';
    if (importancia > 0.3) return 'm√©dia';
    if (importancia > 0.1) return 'baixa';
    return 'muito-baixa';
  },

  /**
   * Simplificar endere√ßo para exibi√ß√£o
   */
  simplificarEndereco(resultado) {
    const partes = [];
    
    if (resultado.address) {
      const a = resultado.address;
      
      if (a.road) partes.push(a.road);
      if (a.house_number) partes.push(a.house_number);
      if (a.suburb || a.neighbourhood) partes.push(a.suburb || a.neighbourhood);
      if (a.city || a.town || a.village) partes.push(a.city || a.town || a.village);
    }
    
    return partes.join(', ') || resultado.display_name;
  },

  /**
   * Calcula dist√¢ncia entre duas coordenadas (Haversine) - ULTRA PRECISO
   */
  calcularDistancia(lat1, lon1, lat2, lon2) {
    const R = 6371.0088; // Raio m√©dio da Terra em km (WGS84)
    const dLat = this.toRad(lat2 - lat1);
    const dLon = this.toRad(lon2 - lon1);
    const a = 
      Math.sin(dLat / 2) * Math.sin(dLat / 2) +
      Math.cos(this.toRad(lat1)) * Math.cos(this.toRad(lat2)) * 
      Math.sin(dLon / 2) * Math.sin(dLon / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  },

  toRad(deg) {
    return deg * (Math.PI / 180);
  },

  /**
   * Estima tempo de chegada baseado na dist√¢ncia (MAIS PRECISO)
   */
  estimarTempo(distanciaKm) {
    // M√©dia de 30km/h em cidade + 20% tr√¢nsito
    const minutos = Math.ceil((distanciaKm / 0.5) * 1.2);
    return Math.max(2, Math.min(minutos, 60)); // Entre 2 e 60 minutos
  },

  /**
   * Limpa o endere√ßo para melhor busca
   */
  limparEndereco(endereco) {
    return endereco
      .trim()
      .replace(/\s+/g, ' ')
      // Normalizar abrevia√ß√µes comuns
      .replace(/\br\.?\s*/gi, 'Rua ')
      .replace(/\bav\.?\s*/gi, 'Avenida ')
      .replace(/\btrav\.?\s*/gi, 'Travessa ')
      .replace(/\bal\.?\s*/gi, 'Alameda ')
      .replace(/\bp√ß\.?\s*/gi, 'Pra√ßa ')
      .replace(/\bn[¬∫¬∞]?\s*/gi, '')
      .replace(/\bnumero\s*/gi, '')
      .replace(/\bnum\s*/gi, '')
      // Remover pontua√ß√£o excessiva
      .replace(/[,]+/g, ',')
      .replace(/^,|,$/g, '');
  },

  /**
   * Verifica se o endere√ßo j√° tem cidade
   */
  temCidade(endereco) {
    const cidades = [
      'guai√ßara', 'guaicara', 'lins', 'mar√≠lia', 'marilia', 
      'bauru', 'assis', 'ourinhos', 'tup√£', 'tupa',
      's√£o paulo', 'sao paulo', 'sp'
    ];
    const lower = endereco.toLowerCase();
    return cidades.some(c => lower.includes(c));
  },

  /**
   * Geocodifica√ß√£o reversa (coordenadas ‚Üí endere√ßo)
   */
  async reverso(latitude, longitude) {
    return new Promise((resolve) => {
      const url = `https://nominatim.openstreetmap.org/reverse?lat=${latitude}&lon=${longitude}&format=json&addressdetails=1`;

      const options = {
        headers: {
          'User-Agent': 'Rebeca-WhatsApp-Bot/1.0 (contato@ubmax.com.br)',
          'Accept-Language': 'pt-BR,pt;q=0.9',
        },
        timeout: 10000,
      };

      https.get(url, options, (res) => {
        let data = '';

        res.on('data', chunk => data += chunk);
        
        res.on('end', () => {
          try {
            const r = JSON.parse(data);
            
            if (r && r.address) {
              const parts = [];
              if (r.address.road) parts.push(r.address.road);
              if (r.address.house_number) parts.push(r.address.house_number);
              if (r.address.suburb || r.address.neighbourhood) {
                parts.push(r.address.suburb || r.address.neighbourhood);
              }
              if (r.address.city || r.address.town || r.address.village) {
                parts.push(r.address.city || r.address.town || r.address.village);
              }

              resolve({
                endereco: parts.join(', ') || r.display_name,
                enderecoCompleto: r.display_name,
                rua: r.address.road,
                numero: r.address.house_number,
                bairro: r.address.suburb || r.address.neighbourhood,
                cidade: r.address.city || r.address.town || r.address.village,
                estado: r.address.state,
                cep: r.address.postcode,
              });
            } else {
              resolve(null);
            }
          } catch (e) {
            console.error('Erro parsing reverso:', e);
            resolve(null);
          }
        });

      }).on('error', (err) => {
        console.error('Erro requisi√ß√£o reverso:', err.message);
        resolve(null);
      });
    });
  },
};

module.exports = GeocodingService;
