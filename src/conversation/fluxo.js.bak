// ========================================
// REBECA - FLUXO DE CONVERSA
// O c√©rebro da Rebeca (com IA)
// FLUXO CORRETO:
// 1. Localiza√ß√£o ou Endere√ßo
// 2. "Encontrei motorista a X min. Posso mandar?"
// 3. Cliente confirma
// 4. "Certinho, est√° a caminho!" + link rastreamento
// ========================================

const { OpenAIService, GeocodingService } = require('../services');
const {
  ClienteRepository,
  MotoristaRepository,
  CorridaRepository,
  ConversaRepository,
  MensagemRepository,
  ConfiguracaoRepository,
} = require('../database');
const { 
  delayResposta, 
  delayConfirmacao, 
  delayBuscaMotorista,
  dentroDoHorario,
} = require('../utils');

const { ETAPAS } = ConversaRepository;
const { INTENCOES } = OpenAIService;

class FluxoConversa {
  constructor(whatsapp) {
    this.whatsapp = whatsapp;
    // Cache de mensagens enviadas por telefone (para n√£o repetir)
    this.mensagensEnviadas = new Map();
  }

  /**
   * Obt√©m mensagens anteriores de um telefone
   */
  getMensagensAnteriores(telefone) {
    return this.mensagensEnviadas.get(telefone) || [];
  }

  /**
   * Adiciona mensagem ao hist√≥rico
   */
  addMensagemEnviada(telefone, mensagem) {
    const anteriores = this.getMensagensAnteriores(telefone);
    anteriores.push(mensagem);
    // Manter apenas √∫ltimas 10 mensagens
    if (anteriores.length > 10) {
      anteriores.shift();
    }
    this.mensagensEnviadas.set(telefone, anteriores);
  }

  /**
   * Limpa hist√≥rico de mensagens
   */
  limparHistorico(telefone) {
    this.mensagensEnviadas.delete(telefone);
  }

  /**
   * Processa uma mensagem recebida
   * @param {Object} msg - Mensagem do WhatsApp
   */
  async processar(msg) {
    const telefone = msg.from.replace('@c.us', '').replace('@s.whatsapp.net', '');
    let texto = msg.body || '';
    const ehLocalizacao = msg.type === 'location';
    const ehAudio = msg.type === 'ptt' || msg.type === 'audio';

    console.log(`üì© Mensagem de ${telefone}: ${texto || (ehAudio ? '[√ÅUDIO]' : '[localiza√ß√£o]')}`);

    // Se for √°udio, transcrever primeiro
    if (ehAudio) {
      try {
        const media = await msg.downloadMedia();
        if (media && media.data) {
          const audioBuffer = Buffer.from(media.data, 'base64');
          const transcricao = await OpenAIService.transcreverAudio(audioBuffer, media.mimetype);
          if (transcricao) {
            texto = transcricao;
            console.log(`üé§ √Åudio transcrito: ${texto}`);
          }
        }
      } catch (error) {
        console.error('‚ùå Erro ao processar √°udio:', error);
      }
    }

    // Registrar mensagem de entrada
    await MensagemRepository.registrarEntrada(
      telefone, 
      ehLocalizacao ? `[LOCALIZA√á√ÉO] ${msg.location?.latitude}, ${msg.location?.longitude}` : 
      ehAudio ? `[√ÅUDIO] ${texto}` : texto,
      ehLocalizacao ? 'localizacao' : ehAudio ? 'audio' : 'texto'
    );

    // Verificar hor√°rio de funcionamento
    if (!dentroDoHorario()) {
      const resposta = await OpenAIService.gerarResposta('FORA_HORARIO', {}, []);
      if (resposta) {
        await this.responder(msg, resposta);
      } else {
        await this.responder(msg, 'Oi! Estamos fora do hor√°rio de atendimento no momento. Retorne mais tarde üëç');
      }
      return;
    }

    // Buscar ou criar cliente
    const cliente = await ClienteRepository.buscarOuCriar(telefone);
    
    // Buscar estado da conversa
    let conversa = await ConversaRepository.buscarPorTelefone(telefone);
    
    // Se n√£o existe conversa, criar uma nova
    if (!conversa) {
      conversa = await ConversaRepository.upsert(
        telefone,
        cliente.id,
        ETAPAS.INICIO,
        {}
      );
    }

    // Usar IA para identificar inten√ß√£o
    const { intencao, endereco_extraido, confianca } = await OpenAIService.identificarIntencao(
      texto,
      conversa.etapa
    );

    console.log(`üß† Inten√ß√£o: ${intencao} (${(confianca * 100).toFixed(0)}%)`);

    // Processar baseado na etapa atual e inten√ß√£o
    await this.processarComIA(msg, cliente, conversa, texto, ehLocalizacao, intencao, endereco_extraido);
  }

  /**
   * Processa usando IA para interpreta√ß√£o
   */
  async processarComIA(msg, cliente, conversa, texto, ehLocalizacao, intencao, enderecoExtraido) {
    const telefone = msg.from.replace('@c.us', '').replace('@s.whatsapp.net', '');
    const etapa = conversa.etapa;
    const ehRecorrente = cliente.recorrente;
    const anteriores = this.getMensagensAnteriores(telefone);

    console.log(`üìç Etapa: ${etapa} | Inten√ß√£o: ${intencao} | Recorrente: ${ehRecorrente}`);

    // Se quer cancelar em qualquer momento
    if (intencao === INTENCOES.QUER_CANCELAR) {
      return await this.processarCancelamento(msg, conversa, anteriores);
    }

    // Se pergunta valor
    if (intencao === INTENCOES.PERGUNTA_VALOR) {
      return await this.responderValor(msg, conversa, anteriores);
    }

    // Se pede desconto
    if (intencao === INTENCOES.PEDE_DESCONTO) {
      return await this.responderSemDesconto(msg, anteriores);
    }

    switch (etapa) {
      case ETAPAS.INICIO:
        await this.etapaInicio(msg, cliente, ehRecorrente, intencao, texto, ehLocalizacao, enderecoExtraido, anteriores);
        break;

      case ETAPAS.AGUARDANDO_RESPOSTA_INICIAL:
        await this.etapaAguardandoResposta(msg, cliente, conversa, ehRecorrente, intencao, texto, ehLocalizacao, enderecoExtraido, anteriores);
        break;

      case ETAPAS.AGUARDANDO_LOCALIZACAO:
        await this.etapaAguardandoLocalizacao(msg, cliente, conversa, texto, ehLocalizacao, intencao, enderecoExtraido, anteriores);
        break;

      // ========================================
      // ETAPA: CONFIRMANDO SE PODE MANDAR MOTORISTA
      // ========================================
      case ETAPAS.CONFIRMANDO:
        await this.etapaConfirmandoMotorista(msg, cliente, conversa, texto, intencao, anteriores);
        break;

      case ETAPAS.BUSCANDO_MOTORISTA:
        await this.responderAguardando(msg, anteriores);
        break;

      case ETAPAS.AGUARDANDO_MOTORISTA:
      case ETAPAS.EM_CORRIDA:
        await this.etapaEmCorrida(msg, conversa, texto, intencao, anteriores);
        break;

      default:
        await ConversaRepository.resetar(telefone);
        this.limparHistorico(telefone);
        await this.etapaInicio(msg, cliente, ehRecorrente, intencao, texto, ehLocalizacao, enderecoExtraido, []);
    }
  }

  /**
   * Etapa inicial - Sauda√ß√£o
   */
  async etapaInicio(msg, cliente, ehRecorrente, intencao, texto, ehLocalizacao, enderecoExtraido, anteriores) {
    const telefone = msg.from.replace('@c.us', '').replace('@s.whatsapp.net', '');

    await delayResposta();

    // Se j√° mandou localiza√ß√£o de cara, processar direto
    if (ehLocalizacao) {
      const resposta = await OpenAIService.gerarResposta('CONFIRMACAO_RECEBIMENTO', {}, anteriores);
      await this.responder(msg, resposta || 'Recebi üëç');

      const origem = { 
        latitude: msg.location?.latitude, 
        longitude: msg.location?.longitude, 
        endereco: msg.location?.address || 'Localiza√ß√£o recebida' 
      };

      await this.buscarEPerguntar(msg, cliente, origem, [...anteriores, resposta]);
      return;
    }

    // Se mandou endere√ßo de cara, geocodificar
    if (intencao === INTENCOES.ENVIOU_ENDERECO || enderecoExtraido) {
      const enderecoDigitado = enderecoExtraido || texto;
      
      await this.responder(msg, 'Deixa eu encontrar esse endere√ßo... üîç');
      
      const origem = await this.geocodificarEndereco(msg, enderecoDigitado, anteriores);
      
      if (origem) {
        await this.buscarEPerguntar(msg, cliente, origem, anteriores);
      }
      // Se n√£o encontrou, geocodificarEndereco j√° pediu localiza√ß√£o
      return;
    }

    // Sauda√ß√£o normal
    const resposta = await OpenAIService.gerarResposta('SAUDACAO', {}, anteriores);
    await this.responder(msg, resposta || 'Oi, tudo bem?');

    await ConversaRepository.upsert(telefone, cliente.id, ETAPAS.AGUARDANDO_RESPOSTA_INICIAL, { ehRecorrente });
  }

  /**
   * Aguardando resposta inicial
   */
  async etapaAguardandoResposta(msg, cliente, conversa, ehRecorrente, intencao, texto, ehLocalizacao, enderecoExtraido, anteriores) {
    const telefone = msg.from.replace('@c.us', '').replace('@s.whatsapp.net', '');

    await delayResposta();

    // Se j√° mandou localiza√ß√£o, processar direto
    if (ehLocalizacao) {
      const origem = { 
        latitude: msg.location?.latitude, 
        longitude: msg.location?.longitude, 
        endereco: msg.location?.address || 'Localiza√ß√£o recebida' 
      };

      await this.buscarEPerguntar(msg, cliente, origem, anteriores);
      return;
    }

    // Se mandou endere√ßo, geocodificar
    if (intencao === INTENCOES.ENVIOU_ENDERECO || enderecoExtraido) {
      const enderecoDigitado = enderecoExtraido || texto;
      
      await this.responder(msg, 'Deixa eu encontrar esse endere√ßo... üîç');
      
      const origem = await this.geocodificarEndereco(msg, enderecoDigitado, anteriores);
      
      if (origem) {
        await this.buscarEPerguntar(msg, cliente, origem, anteriores);
      }
      return;
    }

    // Confirmar e pedir localiza√ß√£o
    const respConfirma = await OpenAIService.gerarResposta('CONFIRMACAO_RECEBIMENTO', {}, anteriores);
    await this.responder(msg, respConfirma || 'Claro üëç');

    await delayResposta();

    const tipoLocal = ehRecorrente ? 'PEDIR_LOCALIZACAO_RECORRENTE' : 'PEDIR_LOCALIZACAO';
    const respLocal = await OpenAIService.gerarResposta(tipoLocal, {}, [...anteriores, respConfirma]);
    await this.responder(msg, respLocal || 'Pode me enviar o endere√ßo ou a localiza√ß√£o?');

    await ConversaRepository.atualizarEtapa(telefone, ETAPAS.AGUARDANDO_LOCALIZACAO);
  }

  /**
   * Aguardando localiza√ß√£o ou endere√ßo
   */
  async etapaAguardandoLocalizacao(msg, cliente, conversa, texto, ehLocalizacao, intencao, enderecoExtraido, anteriores) {
    const telefone = msg.from.replace('@c.us', '').replace('@s.whatsapp.net', '');

    let origem = {};

    // Localiza√ß√£o do WhatsApp (j√° tem coordenadas!)
    if (ehLocalizacao && msg.location) {
      origem = {
        latitude: msg.location.latitude,
        longitude: msg.location.longitude,
        endereco: msg.location.address || 'Localiza√ß√£o recebida',
      };
      console.log(`üìç Localiza√ß√£o WhatsApp recebida: ${origem.latitude}, ${origem.longitude}`);
    } 
    // Endere√ßo digitado - GEOCODIFICAR!
    else {
      const enderecoDigitado = enderecoExtraido || texto;
      
      await delayResposta();
      await this.responder(msg, 'Deixa eu encontrar esse endere√ßo... üîç');

      // GEOCODIFICAR ENDERE√áO
      const geo = await GeocodingService.geocodificar(enderecoDigitado);

      if (geo && geo.latitude && geo.longitude) {
        origem = {
          latitude: geo.latitude,
          longitude: geo.longitude,
          endereco: geo.enderecoFormatado || enderecoDigitado,
          bairro: geo.bairro,
          cidade: geo.cidade,
        };
        console.log(`‚úÖ Endere√ßo geocodificado: ${origem.endereco}`);
        console.log(`   üìç Lat: ${origem.latitude}, Lng: ${origem.longitude}`);
      } else {
        // N√£o encontrou - perguntar de novo
        console.log(`‚ùå N√£o foi poss√≠vel encontrar: "${enderecoDigitado}"`);
        
        await delayResposta();
        const respNaoEncontrei = await OpenAIService.gerarResposta('ENDERECO_NAO_ENCONTRADO', {}, anteriores);
        await this.responder(msg, respNaoEncontrei || 'N√£o consegui encontrar esse endere√ßo üòï Pode enviar a localiza√ß√£o pelo WhatsApp? √â s√≥ clicar no üìé e depois em "Localiza√ß√£o"');
        return; // Continua aguardando
      }
    }

    await delayResposta();

    // Confirmar recebimento
    const respPerfeito = await OpenAIService.gerarResposta('RECEBI_LOCALIZACAO', {}, anteriores);
    await this.responder(msg, respPerfeito || 'Achei! ‚úÖ');

    // ========================================
    // BUSCAR MOTORISTA E PERGUNTAR SE PODE MANDAR
    // ========================================
    await this.buscarEPerguntar(msg, cliente, origem, [...anteriores, respPerfeito]);
  }

  /**
   * ========================================
   * BUSCAR MOTORISTA E PERGUNTAR SE PODE MANDAR
   * Fluxo correto: encontra motorista ‚Üí pergunta ‚Üí confirma ‚Üí envia
   * ========================================
   */
  async buscarEPerguntar(msg, cliente, origem, anteriores) {
    const telefone = msg.from.replace('@c.us', '').replace('@s.whatsapp.net', '');
    const AtribuicaoService = require('../services/atribuicao');

    await delayConfirmacao();

    const respBusca = await OpenAIService.gerarResposta('BUSCANDO_MOTORISTA', {}, anteriores);
    await this.responder(msg, respBusca || 'S√≥ um instante que vou verificar o motorista mais pr√≥ximo.');

    await delayBuscaMotorista();

    // Buscar motorista mais pr√≥ximo (SEM criar corrida ainda)
    const motorista = await AtribuicaoService.buscarMotoristaProximo(origem.latitude, origem.longitude);

    if (!motorista) {
      const respSem = await OpenAIService.gerarResposta('SEM_MOTORISTA', {}, anteriores);
      await this.responder(msg, respSem || 'Poxa, n√£o encontrei motorista dispon√≠vel agora. Tenta de novo em alguns minutos?');
      await ConversaRepository.resetar(telefone);
      this.limparHistorico(telefone);
      return;
    }

    // Calcular tempo estimado
    const tempoMin = motorista.tempo_estimado_min || Math.floor(Math.random() * 5) + 3;

    // ========================================
    // PERGUNTAR SE PODE MANDAR O MOTORISTA
    // ========================================
    const msgPergunta = `Encontrei um motorista a ${tempoMin} minutos de voc√™.\n\nPosso mandar?`;
    await this.responder(msg, msgPergunta);

    // Salvar dados para quando confirmar
    await ConversaRepository.upsert(
      telefone,
      cliente.id,
      ETAPAS.CONFIRMANDO,
      { 
        origem,
        motorista_id: motorista.id,
        motorista_nome: motorista.nome,
        motorista_veiculo: motorista.veiculo_modelo,
        motorista_cor: motorista.veiculo_cor,
        motorista_placa: motorista.veiculo_placa,
        tempo_estimado: tempoMin
      }
    );
  }

  /**
   * ========================================
   * ETAPA: CONFIRMANDO SE PODE MANDAR MOTORISTA
   * Cliente responde "sim" ou "n√£o"
   * ========================================
   */
  async etapaConfirmandoMotorista(msg, cliente, conversa, texto, intencao, anteriores) {
    const telefone = msg.from.replace('@c.us', '').replace('@s.whatsapp.net', '');
    const dados = conversa.dados || {};

    await delayResposta();

    // Se CONFIRMOU (sim, ok, pode, manda, etc)
    if (intencao === INTENCOES.CONFIRMACAO || 
        texto.toLowerCase().match(/^(sim|s|ok|isso|pode|manda|bora|vai|quero|beleza|pode ser|pode mandar|manda sim|sim pode|certo|correto|isso mesmo|√© isso|t√° certo|ta certo|confirmo|confirmado)$/i)) {
      
      // Buscar valor configurado no painel ADM
      const valorCorrida = await ConfiguracaoRepository.getValorCorrida();

      // Agora sim, criar a corrida e atribuir o motorista
      const corrida = await CorridaRepository.criar({
        cliente_id: cliente.id,
        motorista_id: dados.motorista_id,
        origem_endereco: dados.origem?.endereco,
        origem_latitude: dados.origem?.latitude,
        origem_longitude: dados.origem?.longitude,
        valor: valorCorrida,
        status: 'aceita'
      });

      // Marcar motorista como em corrida
      await MotoristaRepository.iniciarCorrida(dados.motorista_id);
      await ClienteRepository.incrementarCorridas(cliente.id);

      // Link de rastreamento (URL relativa - funciona em qualquer dom√≠nio)
      const baseUrl = process.env.BASE_URL || 'http://localhost:3000';
      const linkRastreamento = `${baseUrl}/rastrear/${corrida.id}`;

      // ========================================
      // NOTIFICAR MOTORISTA VIA WEBSOCKET
      // ========================================
      try {
        const io = global.io; // Socket.io global
        if (io) {
          io.to(`motorista_${dados.motorista_id}`).emit('nova-corrida', {
            corrida_id: corrida.id,
            cliente_telefone: telefone,
            origem: dados.origem.endereco,
            origem_lat: dados.origem.latitude,
            origem_lng: dados.origem.longitude,
            valor: 13.00,
            tempo_estimado: dados.tempo_estimado,
          });
          console.log(`üì± Notifica√ß√£o enviada para motorista ${dados.motorista_id}`);
        }
      } catch (wsError) {
        console.error('Erro ao notificar motorista:', wsError);
      }

      // ========================================
      // MENSAGEM FINAL: CERTINHO + DADOS + LINK
      // ========================================
      const msgFinal = `Certinho, est√° a caminho! üöó

üë§ Nome: ${dados.motorista_nome}
üöô Ve√≠culo: ${dados.motorista_veiculo} ${dados.motorista_cor}
üìç Placa: ${dados.motorista_placa}
‚è±Ô∏è Tempo estimado: ${dados.tempo_estimado} minutos

Acompanhe a localiza√ß√£o em tempo real:
${linkRastreamento}`;

      await this.responder(msg, msgFinal);

      await ConversaRepository.upsert(
        telefone,
        cliente.id,
        ETAPAS.EM_CORRIDA,
        dados,
        corrida.id
      );
      return;
    }

    // Se NEGOU (n√£o, cancela, etc)
    if (intencao === INTENCOES.NEGACAO || 
        texto.toLowerCase().match(/^(n√£o|nao|n|cancela|deixa|agora n√£o|agora nao|depois|errado|outro|outra|diferente|mudou|muda|trocar|troca)$/i)) {
      
      const resposta = await OpenAIService.gerarResposta('CORRIDA_CANCELADA', {}, anteriores);
      await this.responder(msg, resposta || 'Sem problema! Se precisar, √© s√≥ chamar.');
      await ConversaRepository.resetar(telefone);
      this.limparHistorico(telefone);
      return;
    }

    // N√£o entendeu - perguntar de novo
    await this.responder(msg, 'Posso mandar o motorista? Responde "sim" ou "n√£o".');
  }

  /**
   * Em corrida
   */
  async etapaEmCorrida(msg, conversa, texto, intencao, anteriores) {
    await delayResposta();

    const resposta = await OpenAIService.gerarResposta('AGUARDANDO_MOTORISTA', {}, anteriores);
    await this.responder(msg, resposta || 'Seu motorista j√° est√° a caminho.');
  }

  /**
   * Responder valor - BUSCA DO PAINEL ADM
   */
  async responderValor(msg, conversa, anteriores) {

  /**
   * ========================================
   * PERGUNTAR REFER√äNCIA AP√ìS ENDERE√áO
   * ========================================
   */
  async perguntarReferencia(msg, cliente, origem, anteriores) {
    const telefone = msg.from.replace('@c.us', '').replace('@s.whatsapp.net', '');

    await delayResposta();

    // Confirmar endere√ßo e pedir refer√™ncia
    const msgReferencia = `üìç Entendi! Voc√™ est√° em:\n${origem.endereco}\n\nTem algum ponto de refer√™ncia? (Ex: pr√≥ximo ao mercado, em frente √† farm√°cia, port√£o azul...)\n\nSe n√£o tiver, pode responder "n√£o" ou "nenhum".`;
    
    await this.responder(msg, msgReferencia);

    // Salvar dados e mudar para etapa de refer√™ncia
    await ConversaRepository.upsert(
      telefone,
      cliente.id,
      ETAPAS.AGUARDANDO_REFERENCIA,
      { origem }
    );
  }

  /**
   * ========================================
   * ETAPA: AGUARDANDO REFER√äNCIA
   * Cliente informa ponto de refer√™ncia
   * ========================================
   */
  async etapaAguardandoReferencia(msg, cliente, conversa, texto, intencao, anteriores) {
    const telefone = msg.from.replace('@c.us', '').replace('@s.whatsapp.net', '');
    const dados = conversa.dados || {};

    await delayResposta();

    // Verificar se tem refer√™ncia ou se cliente disse que n√£o tem
    let referencia = null;
    const semReferencia = texto.toLowerCase().match(/^(n√£o|nao|n|nenhum|nenhuma|nada|sem|pular|nope|no)$/i);
    
    if (!semReferencia && texto.length > 2) {
      // Cliente informou refer√™ncia
      referencia = texto.trim();
      console.log(`üìç Refer√™ncia recebida: "${referencia}"`);
    }

    // Salvar refer√™ncia na origem
    const origem = {
      ...dados.origem,
      referencia: referencia
    };

    // Agora buscar motorista
    await this.buscarMotoristaComReferencia(msg, cliente, origem, referencia, anteriores);
  }

  /**
   * Buscar motorista ap√≥s ter endere√ßo E refer√™ncia
   */
  async buscarMotoristaComReferencia(msg, cliente, origem, referencia, anteriores) {
    const telefone = msg.from.replace('@c.us', '').replace('@s.whatsapp.net', '');
    const AtribuicaoService = require('../services/atribuicao');

    await delayConfirmacao();

    const respBusca = await OpenAIService.gerarResposta('BUSCANDO_MOTORISTA', {}, anteriores);
    await this.responder(msg, respBusca || 'S√≥ um instante que vou verificar o motorista mais pr√≥ximo...');

    await delayBuscaMotorista();

    // Buscar motorista mais pr√≥ximo
    const motorista = await AtribuicaoService.buscarMotoristaProximo(origem.latitude, origem.longitude);

    if (!motorista) {
      const respSem = await OpenAIService.gerarResposta('SEM_MOTORISTA', {}, anteriores);
      await this.responder(msg, respSem || 'Poxa, n√£o encontrei motorista dispon√≠vel agora. Tenta de novo em alguns minutos?');
      await ConversaRepository.resetar(telefone);
      this.limparHistorico(telefone);
      return;
    }

    // Calcular tempo estimado
    const tempoMin = motorista.tempo_estimado_min || Math.floor(Math.random() * 5) + 3;

    // Perguntar se pode mandar
    const msgPergunta = `Encontrei um motorista a ${tempoMin} minutos de voc√™.\n\nPosso mandar?`;
    await this.responder(msg, msgPergunta);

    // Salvar dados COM refer√™ncia
    await ConversaRepository.upsert(
      telefone,
      cliente.id,
      ETAPAS.CONFIRMANDO,
      { 
        origem,
        referencia: referencia,
        motorista_id: motorista.id,
        motorista_nome: motorista.nome,
        motorista_veiculo: motorista.veiculo_modelo,
        motorista_cor: motorista.veiculo_cor,
        motorista_placa: motorista.veiculo_placa,
        tempo_estimado: tempoMin
      }
    );
  }

    await delayResposta();

    // Buscar valor configurado no painel ADM
    let valor = await ConfiguracaoRepository.getValorCorrida();
    
    // Se tiver corrida em andamento, usa o valor dela
    if (conversa.corrida_atual_id) {
      const corrida = await CorridaRepository.buscarPorId(conversa.corrida_atual_id);
      if (corrida?.valor) {
        valor = corrida.valor;
      }
    }

    const resposta = await OpenAIService.gerarResposta('VALOR_CORRIDA', { 
      valor: valor.toFixed(2).replace('.', ',') 
    }, anteriores);
    
    await this.responder(msg, resposta || `O valor √© R$ ${valor.toFixed(2).replace('.', ',')}, conforme definido pela frota.`);
  }

  /**
   * Responder sem desconto
   */
  async responderSemDesconto(msg, anteriores) {

  /**
   * ========================================
   * PERGUNTAR REFER√äNCIA AP√ìS ENDERE√áO
   * ========================================
   */
  async perguntarReferencia(msg, cliente, origem, anteriores) {
    const telefone = msg.from.replace('@c.us', '').replace('@s.whatsapp.net', '');

    await delayResposta();

    // Confirmar endere√ßo e pedir refer√™ncia
    const msgReferencia = `üìç Entendi! Voc√™ est√° em:\n${origem.endereco}\n\nTem algum ponto de refer√™ncia? (Ex: pr√≥ximo ao mercado, em frente √† farm√°cia, port√£o azul...)\n\nSe n√£o tiver, pode responder "n√£o" ou "nenhum".`;
    
    await this.responder(msg, msgReferencia);

    // Salvar dados e mudar para etapa de refer√™ncia
    await ConversaRepository.upsert(
      telefone,
      cliente.id,
      ETAPAS.AGUARDANDO_REFERENCIA,
      { origem }
    );
  }

  /**
   * ========================================
   * ETAPA: AGUARDANDO REFER√äNCIA
   * Cliente informa ponto de refer√™ncia
   * ========================================
   */
  async etapaAguardandoReferencia(msg, cliente, conversa, texto, intencao, anteriores) {
    const telefone = msg.from.replace('@c.us', '').replace('@s.whatsapp.net', '');
    const dados = conversa.dados || {};

    await delayResposta();

    // Verificar se tem refer√™ncia ou se cliente disse que n√£o tem
    let referencia = null;
    const semReferencia = texto.toLowerCase().match(/^(n√£o|nao|n|nenhum|nenhuma|nada|sem|pular|nope|no)$/i);
    
    if (!semReferencia && texto.length > 2) {
      // Cliente informou refer√™ncia
      referencia = texto.trim();
      console.log(`üìç Refer√™ncia recebida: "${referencia}"`);
    }

    // Salvar refer√™ncia na origem
    const origem = {
      ...dados.origem,
      referencia: referencia
    };

    // Agora buscar motorista
    await this.buscarMotoristaComReferencia(msg, cliente, origem, referencia, anteriores);
  }

  /**
   * Buscar motorista ap√≥s ter endere√ßo E refer√™ncia
   */
  async buscarMotoristaComReferencia(msg, cliente, origem, referencia, anteriores) {
    const telefone = msg.from.replace('@c.us', '').replace('@s.whatsapp.net', '');
    const AtribuicaoService = require('../services/atribuicao');

    await delayConfirmacao();

    const respBusca = await OpenAIService.gerarResposta('BUSCANDO_MOTORISTA', {}, anteriores);
    await this.responder(msg, respBusca || 'S√≥ um instante que vou verificar o motorista mais pr√≥ximo...');

    await delayBuscaMotorista();

    // Buscar motorista mais pr√≥ximo
    const motorista = await AtribuicaoService.buscarMotoristaProximo(origem.latitude, origem.longitude);

    if (!motorista) {
      const respSem = await OpenAIService.gerarResposta('SEM_MOTORISTA', {}, anteriores);
      await this.responder(msg, respSem || 'Poxa, n√£o encontrei motorista dispon√≠vel agora. Tenta de novo em alguns minutos?');
      await ConversaRepository.resetar(telefone);
      this.limparHistorico(telefone);
      return;
    }

    // Calcular tempo estimado
    const tempoMin = motorista.tempo_estimado_min || Math.floor(Math.random() * 5) + 3;

    // Perguntar se pode mandar
    const msgPergunta = `Encontrei um motorista a ${tempoMin} minutos de voc√™.\n\nPosso mandar?`;
    await this.responder(msg, msgPergunta);

    // Salvar dados COM refer√™ncia
    await ConversaRepository.upsert(
      telefone,
      cliente.id,
      ETAPAS.CONFIRMANDO,
      { 
        origem,
        referencia: referencia,
        motorista_id: motorista.id,
        motorista_nome: motorista.nome,
        motorista_veiculo: motorista.veiculo_modelo,
        motorista_cor: motorista.veiculo_cor,
        motorista_placa: motorista.veiculo_placa,
        tempo_estimado: tempoMin
      }
    );
  }

    await delayResposta();

    const resposta = await OpenAIService.gerarResposta('SEM_DESCONTO', {}, anteriores);
    await this.responder(msg, resposta || 'Esse valor √© o que est√° configurado no sistema no momento.');
  }

  /**
   * Responder aguardando
   */
  async responderAguardando(msg, anteriores) {

  /**
   * ========================================
   * PERGUNTAR REFER√äNCIA AP√ìS ENDERE√áO
   * ========================================
   */
  async perguntarReferencia(msg, cliente, origem, anteriores) {
    const telefone = msg.from.replace('@c.us', '').replace('@s.whatsapp.net', '');

    await delayResposta();

    // Confirmar endere√ßo e pedir refer√™ncia
    const msgReferencia = `üìç Entendi! Voc√™ est√° em:\n${origem.endereco}\n\nTem algum ponto de refer√™ncia? (Ex: pr√≥ximo ao mercado, em frente √† farm√°cia, port√£o azul...)\n\nSe n√£o tiver, pode responder "n√£o" ou "nenhum".`;
    
    await this.responder(msg, msgReferencia);

    // Salvar dados e mudar para etapa de refer√™ncia
    await ConversaRepository.upsert(
      telefone,
      cliente.id,
      ETAPAS.AGUARDANDO_REFERENCIA,
      { origem }
    );
  }

  /**
   * ========================================
   * ETAPA: AGUARDANDO REFER√äNCIA
   * Cliente informa ponto de refer√™ncia
   * ========================================
   */
  async etapaAguardandoReferencia(msg, cliente, conversa, texto, intencao, anteriores) {
    const telefone = msg.from.replace('@c.us', '').replace('@s.whatsapp.net', '');
    const dados = conversa.dados || {};

    await delayResposta();

    // Verificar se tem refer√™ncia ou se cliente disse que n√£o tem
    let referencia = null;
    const semReferencia = texto.toLowerCase().match(/^(n√£o|nao|n|nenhum|nenhuma|nada|sem|pular|nope|no)$/i);
    
    if (!semReferencia && texto.length > 2) {
      // Cliente informou refer√™ncia
      referencia = texto.trim();
      console.log(`üìç Refer√™ncia recebida: "${referencia}"`);
    }

    // Salvar refer√™ncia na origem
    const origem = {
      ...dados.origem,
      referencia: referencia
    };

    // Agora buscar motorista
    await this.buscarMotoristaComReferencia(msg, cliente, origem, referencia, anteriores);
  }

  /**
   * Buscar motorista ap√≥s ter endere√ßo E refer√™ncia
   */
  async buscarMotoristaComReferencia(msg, cliente, origem, referencia, anteriores) {
    const telefone = msg.from.replace('@c.us', '').replace('@s.whatsapp.net', '');
    const AtribuicaoService = require('../services/atribuicao');

    await delayConfirmacao();

    const respBusca = await OpenAIService.gerarResposta('BUSCANDO_MOTORISTA', {}, anteriores);
    await this.responder(msg, respBusca || 'S√≥ um instante que vou verificar o motorista mais pr√≥ximo...');

    await delayBuscaMotorista();

    // Buscar motorista mais pr√≥ximo
    const motorista = await AtribuicaoService.buscarMotoristaProximo(origem.latitude, origem.longitude);

    if (!motorista) {
      const respSem = await OpenAIService.gerarResposta('SEM_MOTORISTA', {}, anteriores);
      await this.responder(msg, respSem || 'Poxa, n√£o encontrei motorista dispon√≠vel agora. Tenta de novo em alguns minutos?');
      await ConversaRepository.resetar(telefone);
      this.limparHistorico(telefone);
      return;
    }

    // Calcular tempo estimado
    const tempoMin = motorista.tempo_estimado_min || Math.floor(Math.random() * 5) + 3;

    // Perguntar se pode mandar
    const msgPergunta = `Encontrei um motorista a ${tempoMin} minutos de voc√™.\n\nPosso mandar?`;
    await this.responder(msg, msgPergunta);

    // Salvar dados COM refer√™ncia
    await ConversaRepository.upsert(
      telefone,
      cliente.id,
      ETAPAS.CONFIRMANDO,
      { 
        origem,
        referencia: referencia,
        motorista_id: motorista.id,
        motorista_nome: motorista.nome,
        motorista_veiculo: motorista.veiculo_modelo,
        motorista_cor: motorista.veiculo_cor,
        motorista_placa: motorista.veiculo_placa,
        tempo_estimado: tempoMin
      }
    );
  }

    await delayResposta();

    const resposta = await OpenAIService.gerarResposta('AGUARDANDO_MOTORISTA', {}, anteriores);
    await this.responder(msg, resposta || 'Estou verificando, s√≥ um instante.');
  }

  /**
   * Cancelamento
   */
  async processarCancelamento(msg, conversa, anteriores) {
    const telefone = msg.from.replace('@c.us', '').replace('@s.whatsapp.net', '');

    if (conversa.corrida_atual_id) {
      const corrida = await CorridaRepository.buscarPorId(conversa.corrida_atual_id);
      
      if (corrida && ['aguardando', 'enviada', 'aceita'].includes(corrida.status)) {
        await CorridaRepository.cancelar(corrida.id, 'Cancelado pelo cliente');
        
        if (corrida.motorista_id) {
          await MotoristaRepository.finalizarCorrida(corrida.motorista_id);
        }
      }
    }

    await delayResposta();

    const resposta = await OpenAIService.gerarResposta('CORRIDA_CANCELADA', {}, anteriores);
    await this.responder(msg, resposta || 'Corrida cancelada. Se precisar de outra, √© s√≥ chamar.');

    await ConversaRepository.resetar(telefone);
    this.limparHistorico(telefone);
  }

  /**
   * Finalizar corrida (chamado externamente)
   */
  async finalizarCorrida(corridaId) {
    const corrida = await CorridaRepository.buscarPorId(corridaId);
    if (!corrida) return;

    await CorridaRepository.finalizar(corridaId);
    
    if (corrida.motorista_id) {
      await MotoristaRepository.finalizarCorrida(corrida.motorista_id);
    }

    const telefoneCliente = corrida.cliente_telefone + '@c.us';
    const anteriores = this.getMensagensAnteriores(corrida.cliente_telefone);
    
    const resposta = await OpenAIService.gerarResposta('CORRIDA_FINALIZADA', {}, anteriores);
    await this.whatsapp.enviarMensagem(telefoneCliente, resposta || 'Corrida finalizada! Obrigada üëç');

    await MensagemRepository.registrarSaida(corrida.cliente_telefone, resposta);

    await ConversaRepository.resetar(corrida.cliente_telefone);
    this.limparHistorico(corrida.cliente_telefone);
  }

  /**
   * ========================================
   * GEOCODIFICAR ENDERE√áO
   * Converte endere√ßo digitado em coordenadas
   * ========================================
   */
  async geocodificarEndereco(msg, enderecoDigitado, anteriores) {
    const telefone = msg.from.replace('@c.us', '').replace('@s.whatsapp.net', '');

    try {
      // Tentar geocodificar
      const geo = await GeocodingService.geocodificar(enderecoDigitado);

      if (geo && geo.latitude && geo.longitude) {
        console.log(`‚úÖ Endere√ßo geocodificado: ${geo.enderecoFormatado}`);
        
        return {
          latitude: geo.latitude,
          longitude: geo.longitude,
          endereco: geo.enderecoFormatado || enderecoDigitado,
          bairro: geo.bairro,
          cidade: geo.cidade,
        };
      } else {
        // N√£o encontrou - pedir localiza√ß√£o
        console.log(`‚ùå Geocoding falhou para: "${enderecoDigitado}"`);
        
        await delayResposta();
        const respNaoEncontrei = await OpenAIService.gerarResposta('ENDERECO_NAO_ENCONTRADO', {}, anteriores);
        await this.responder(msg, respNaoEncontrei || 'N√£o consegui encontrar esse endere√ßo üòï Pode enviar a localiza√ß√£o pelo WhatsApp?');
        
        return null;
      }
    } catch (error) {
      console.error('‚ùå Erro no geocoding:', error);
      
      // Em caso de erro, pedir localiza√ß√£o
      await delayResposta();
      await this.responder(msg, 'Tive um probleminha pra encontrar o endere√ßo. Pode mandar a localiza√ß√£o pelo WhatsApp? üìç');
      
      return null;
    }
  }

  /**
   * Envia resposta
   */
  async responder(msg, texto) {

  /**
   * ========================================
   * PERGUNTAR REFER√äNCIA AP√ìS ENDERE√áO
   * ========================================
   */
  async perguntarReferencia(msg, cliente, origem, anteriores) {
    const telefone = msg.from.replace('@c.us', '').replace('@s.whatsapp.net', '');

    await delayResposta();

    // Confirmar endere√ßo e pedir refer√™ncia
    const msgReferencia = `üìç Entendi! Voc√™ est√° em:\n${origem.endereco}\n\nTem algum ponto de refer√™ncia? (Ex: pr√≥ximo ao mercado, em frente √† farm√°cia, port√£o azul...)\n\nSe n√£o tiver, pode responder "n√£o" ou "nenhum".`;
    
    await this.responder(msg, msgReferencia);

    // Salvar dados e mudar para etapa de refer√™ncia
    await ConversaRepository.upsert(
      telefone,
      cliente.id,
      ETAPAS.AGUARDANDO_REFERENCIA,
      { origem }
    );
  }

  /**
   * ========================================
   * ETAPA: AGUARDANDO REFER√äNCIA
   * Cliente informa ponto de refer√™ncia
   * ========================================
   */
  async etapaAguardandoReferencia(msg, cliente, conversa, texto, intencao, anteriores) {
    const telefone = msg.from.replace('@c.us', '').replace('@s.whatsapp.net', '');
    const dados = conversa.dados || {};

    await delayResposta();

    // Verificar se tem refer√™ncia ou se cliente disse que n√£o tem
    let referencia = null;
    const semReferencia = texto.toLowerCase().match(/^(n√£o|nao|n|nenhum|nenhuma|nada|sem|pular|nope|no)$/i);
    
    if (!semReferencia && texto.length > 2) {
      // Cliente informou refer√™ncia
      referencia = texto.trim();
      console.log(`üìç Refer√™ncia recebida: "${referencia}"`);
    }

    // Salvar refer√™ncia na origem
    const origem = {
      ...dados.origem,
      referencia: referencia
    };

    // Agora buscar motorista
    await this.buscarMotoristaComReferencia(msg, cliente, origem, referencia, anteriores);
  }

  /**
   * Buscar motorista ap√≥s ter endere√ßo E refer√™ncia
   */
  async buscarMotoristaComReferencia(msg, cliente, origem, referencia, anteriores) {
    const telefone = msg.from.replace('@c.us', '').replace('@s.whatsapp.net', '');
    const AtribuicaoService = require('../services/atribuicao');

    await delayConfirmacao();

    const respBusca = await OpenAIService.gerarResposta('BUSCANDO_MOTORISTA', {}, anteriores);
    await this.responder(msg, respBusca || 'S√≥ um instante que vou verificar o motorista mais pr√≥ximo...');

    await delayBuscaMotorista();

    // Buscar motorista mais pr√≥ximo
    const motorista = await AtribuicaoService.buscarMotoristaProximo(origem.latitude, origem.longitude);

    if (!motorista) {
      const respSem = await OpenAIService.gerarResposta('SEM_MOTORISTA', {}, anteriores);
      await this.responder(msg, respSem || 'Poxa, n√£o encontrei motorista dispon√≠vel agora. Tenta de novo em alguns minutos?');
      await ConversaRepository.resetar(telefone);
      this.limparHistorico(telefone);
      return;
    }

    // Calcular tempo estimado
    const tempoMin = motorista.tempo_estimado_min || Math.floor(Math.random() * 5) + 3;

    // Perguntar se pode mandar
    const msgPergunta = `Encontrei um motorista a ${tempoMin} minutos de voc√™.\n\nPosso mandar?`;
    await this.responder(msg, msgPergunta);

    // Salvar dados COM refer√™ncia
    await ConversaRepository.upsert(
      telefone,
      cliente.id,
      ETAPAS.CONFIRMANDO,
      { 
        origem,
        referencia: referencia,
        motorista_id: motorista.id,
        motorista_nome: motorista.nome,
        motorista_veiculo: motorista.veiculo_modelo,
        motorista_cor: motorista.veiculo_cor,
        motorista_placa: motorista.veiculo_placa,
        tempo_estimado: tempoMin
      }
    );
  }

    const telefone = msg.from.replace('@c.us', '').replace('@s.whatsapp.net', '');

    console.log(`üì§ Enviando para ${telefone}: ${texto}`);

    await this.whatsapp.enviarMensagem(msg.from, texto);
    await MensagemRepository.registrarSaida(telefone, texto);

    // Guardar no hist√≥rico para n√£o repetir
    this.addMensagemEnviada(telefone, texto);
  }
}

module.exports = FluxoConversa;
