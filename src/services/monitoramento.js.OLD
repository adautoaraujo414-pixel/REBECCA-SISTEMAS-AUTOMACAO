// ========================================
// REBECA - MONITORAMENTO DE CORRIDAS
// Controla atrasos, cancela e reatribui
// Integrado com Anti-Fraude e Notifica√ß√µes
// ========================================

const { query } = require('../database/connection');
const { AntiFraude } = require('./antifraude');

// Configura√ß√µes de tempo (em minutos)
const CONFIG_TEMPO = {
  // Toler√¢ncia antes de avisar o cliente (minutos ap√≥s previs√£o)
  TOLERANCIA_AVISO: 2,
  
  // Tempo m√°ximo de atraso antes de cancelar (minutos ap√≥s previs√£o)
  TEMPO_MAX_ATRASO: 5,
  
  // Intervalo de verifica√ß√£o (ms)
  INTERVALO_VERIFICACAO: 30000, // 30 segundos
  
  // Dist√¢ncia m√≠nima para considerar "chegou" (metros)
  DISTANCIA_CHEGADA: 100,
  
  // Intervalo de verifica√ß√£o anti-fraude (ms)
  INTERVALO_ANTIFRAUDE: 300000, // 5 minutos
};

// Status de monitoramento
const STATUS_CORRIDA = {
  AGUARDANDO_MOTORISTA: 'aguardando_motorista',
  MOTORISTA_A_CAMINHO: 'motorista_a_caminho',
  MOTORISTA_CHEGOU: 'motorista_chegou',
  EM_VIAGEM: 'em_viagem',
  FINALIZADA: 'finalizada',
  CANCELADA: 'cancelada',
  CANCELADA_ATRASO: 'cancelada_atraso',
};

class MonitoramentoCorridas {
  constructor(whatsappClient, atribuicaoService) {
    this.whatsapp = whatsappClient;
    this.atribuicao = atribuicaoService;
    this.corridasMonitoradas = new Map();
    this.intervalo = null;
    this.intervaloAntiFraude = null;
    this.antiFraude = new AntiFraude(whatsappClient);
    this.telefoneADM = null; // Ser√° carregado da configura√ß√£o
  }

  /**
   * Inicia o monitoramento
   */
  async iniciar() {
    console.log('üëÅÔ∏è Monitoramento de corridas iniciado');
    
    // Carregar telefone do ADM para notifica√ß√µes
    await this.carregarConfigADM();
    
    // Monitoramento de corridas (atrasos)
    this.intervalo = setInterval(() => {
      this.verificarTodasCorridas();
    }, CONFIG_TEMPO.INTERVALO_VERIFICACAO);
    
    // Verifica√ß√£o peri√≥dica de anti-fraude
    this.intervaloAntiFraude = setInterval(() => {
      this.verificarAntiFraude();
    }, CONFIG_TEMPO.INTERVALO_ANTIFRAUDE);
    
    // Carregar corridas ativas ao iniciar
    this.carregarCorridasAtivas();
    
    // Verificar anti-fraude na inicializa√ß√£o (ap√≥s 30 segundos)
    setTimeout(() => this.verificarAntiFraude(), 30000);
  }

  /**
   * Para o monitoramento
   */
  parar() {
    if (this.intervalo) {
      clearInterval(this.intervalo);
      this.intervalo = null;
    }
    if (this.intervaloAntiFraude) {
      clearInterval(this.intervaloAntiFraude);
      this.intervaloAntiFraude = null;
    }
    console.log('‚èπÔ∏è Monitoramento de corridas parado');
  }

  /**
   * Carrega configura√ß√£o do ADM (telefone para notifica√ß√µes)
   */
  async carregarConfigADM() { try { const result = await query(`SELECT valor FROM configuracoes WHERE chave = 'telefone_adm' LIMIT 1`); if (result.rows[0]) { this.telefoneADM = result.rows[0].valor; } } catch (error) { console.log('?? Telefone ADM n„o configurado para notificaÁıes'); } }
    } catch (error) {
      console.log('‚ö†Ô∏è Telefone ADM n√£o configurado para notifica√ß√µes');
    }
  }

  /**
   * Carrega corridas ativas do banco
   */
  async carregarCorridasAtivas() {
    try {
      const result = await query(`
        SELECT c.*, m.nome as motorista_nome, m.telefone as motorista_telefone,
               m.latitude as motorista_lat, m.longitude as motorista_lng,
               cl.telefone as cliente_telefone, cl.nome as cliente_nome
        FROM corridas c
        JOIN motoristas m ON c.motorista_id = m.id
        JOIN clientes cl ON c.cliente_id = cl.id
        WHERE c.status IN ('aceita', 'motorista_a_caminho')
          AND c.solicitado_em > NOW() - INTERVAL '2 hours'
      `);

      for (const corrida of result.rows) {
        this.adicionarMonitoramento(corrida);
      }

      console.log(`üìã ${result.rows.length} corridas carregadas para monitoramento`);
    } catch (error) {
      console.error('‚ùå Erro ao carregar corridas:', error);
    }
  }

  /**
   * Adiciona corrida ao monitoramento
   */
  adicionarMonitoramento(corrida) {
    const dados = {
      id: corrida.id,
      cliente_id: corrida.cliente_id,
      cliente_telefone: corrida.cliente_telefone,
      cliente_nome: corrida.cliente_nome,
      motorista_id: corrida.motorista_id,
      motorista_nome: corrida.motorista_nome,
      motorista_telefone: corrida.motorista_telefone,
      origem_lat: corrida.origem_lat,
      origem_lng: corrida.origem_lng,
      origem_endereco: corrida.origem_endereco,
      destino_endereco: corrida.destino_endereco,
      tempo_estimado: corrida.tempo_estimado || 5, // minutos
      hora_aceite: corrida.aceito_em || new Date(),
      hora_prevista_chegada: this.calcularHoraPrevista(corrida),
      avisou_atraso: false,
      tentativas_reatribuicao: corrida.tentativas_reatribuicao || 0,
      prioridade: corrida.prioridade || false,
    };

    this.corridasMonitoradas.set(corrida.id, dados);
    console.log(`üëÅÔ∏è Corrida #${corrida.id} adicionada ao monitoramento (ETA: ${dados.tempo_estimado} min)`);
  }

  /**
   * Remove corrida do monitoramento
   */
  removerMonitoramento(corridaId) {
    this.corridasMonitoradas.delete(corridaId);
    console.log(`‚úÖ Corrida #${corridaId} removida do monitoramento`);
  }

  /**
   * Calcula hora prevista de chegada
   */
  calcularHoraPrevista(corrida) {
    const horaAceite = new Date(corrida.aceito_em || new Date());
    const tempoEstimado = corrida.tempo_estimado || 5;
    return new Date(horaAceite.getTime() + tempoEstimado * 60 * 1000);
  }

  /**
   * Verifica todas as corridas monitoradas
   */
  async verificarTodasCorridas() {
    const agora = new Date();

    for (const [corridaId, dados] of this.corridasMonitoradas) {
      try {
        await this.verificarCorrida(corridaId, dados, agora);
      } catch (error) {
        console.error(`‚ùå Erro ao verificar corrida #${corridaId}:`, error);
      }
    }
  }

  /**
   * Verifica uma corrida espec√≠fica
   */
  async verificarCorrida(corridaId, dados, agora) {
    // Buscar status atual da corrida
    const corridaAtual = await this.buscarCorridaAtual(corridaId);
    
    if (!corridaAtual) {
      this.removerMonitoramento(corridaId);
      return;
    }

    // Se j√° chegou, finalizou ou cancelou, remover do monitoramento
    if (['motorista_chegou', 'em_viagem', 'finalizada', 'cancelada', 'cancelada_atraso'].includes(corridaAtual.status)) {
      this.removerMonitoramento(corridaId);
      return;
    }

    // Calcular atraso
    const minutosAtraso = this.calcularMinutosAtraso(dados.hora_prevista_chegada, agora);

    console.log(`‚è±Ô∏è Corrida #${corridaId}: ${minutosAtraso.toFixed(1)} min de atraso`);

    // 1. Se passou da toler√¢ncia e n√£o avisou ainda ‚Üí AVISAR CLIENTE
    if (minutosAtraso >= CONFIG_TEMPO.TOLERANCIA_AVISO && !dados.avisou_atraso) {
      await this.avisarClienteAtraso(dados, minutosAtraso);
      dados.avisou_atraso = true;
      this.corridasMonitoradas.set(corridaId, dados);
    }

    // 2. Se passou do tempo m√°ximo ‚Üí CANCELAR E REATRIBUIR
    if (minutosAtraso >= CONFIG_TEMPO.TEMPO_MAX_ATRASO) {
      await this.cancelarPorAtrasoEReatribuir(dados);
    }
  }

  /**
   * Busca corrida atual no banco
   */
  async buscarCorridaAtual(corridaId) {
    try {
      const result = await query(`
        SELECT c.*, m.latitude as motorista_lat, m.longitude as motorista_lng
        FROM corridas c
        LEFT JOIN motoristas m ON c.motorista_id = m.id
        WHERE c.id = $1
      `, [corridaId]);

      return result.rows[0] || null;
    } catch (error) {
      console.error('Erro ao buscar corrida:', error);
      return null;
    }
  }

  /**
   * Calcula minutos de atraso
   */
  calcularMinutosAtraso(horaPrevista, agora) {
    const diff = agora.getTime() - new Date(horaPrevista).getTime();
    return diff / (1000 * 60); // Em minutos
  }

  /**
   * Avisa cliente sobre atraso
   */
  async avisarClienteAtraso(dados, minutosAtraso) {
    console.log(`‚ö†Ô∏è Avisando cliente sobre atraso na corrida #${dados.id}`);

    // Mensagem CURTA conforme padr√£o Rebeca
    const mensagem = `‚ö†Ô∏è ${dados.motorista_nome} est√° com um pequeno atraso.

Se demorar muito, vou buscar outro pra voc√™.`;

    try {
      // Enviar mensagem para o cliente
      await this.whatsapp.enviarMensagem(dados.cliente_telefone, mensagem);

      // Registrar no banco
      await query(`
        INSERT INTO mensagens (telefone, tipo, conteudo, direcao)
        VALUES ($1, 'texto', $2, 'saida')
      `, [dados.cliente_telefone, mensagem]);

      // Avisar motorista tamb√©m
      const mensagemMotorista = `‚ö†Ô∏è Voc√™ est√° atrasado.

Cliente: ${dados.cliente_nome}
Local: ${dados.origem_endereco}

Agilize ou avise se tiver problema.`;

      await this.whatsapp.enviarMensagem(dados.motorista_telefone, mensagemMotorista);

      console.log(`‚úÖ Cliente e motorista avisados sobre atraso`);
    } catch (error) {
      console.error('‚ùå Erro ao avisar sobre atraso:', error);
    }
  }

  /**
   * Cancela corrida por atraso e busca outro motorista
   */
  async cancelarPorAtrasoEReatribuir(dados) {
    console.log(`üîÑ Cancelando corrida #${dados.id} por atraso e buscando outro motorista`);

    try {
      // 1. Cancelar corrida atual
      await query(`
        UPDATE corridas 
        SET status = 'cancelada_atraso',
            cancelado_em = NOW(),
            motivo_cancelamento = 'Motorista n√£o chegou no tempo estimado'
        WHERE id = $1
      `, [dados.id]);

      // 2. Marcar motorista como "atrasou" (para estat√≠sticas)
      await query(`
        UPDATE motoristas 
        SET qtd_atrasos = COALESCE(qtd_atrasos, 0) + 1,
            atualizado_em = NOW()
        WHERE id = $1
      `, [dados.motorista_id]);

      // 2.1 Registrar no sistema Anti-Fraude e notificar ADM se necess√°rio
      await this.registrarAtrasoAntiFraude(dados.motorista_id, dados.motorista_nome, dados.id);

      // 3. Avisar motorista que foi substitu√≠do
      const mensagemMotoristaRemovido = `‚ùå Corrida cancelada por atraso.

O cliente foi redirecionado pra outro motorista.`;

      await this.whatsapp.enviarMensagem(dados.motorista_telefone, mensagemMotoristaRemovido);

      // 4. Buscar novo motorista (excluindo o que atrasou)
      const novoMotorista = await this.buscarNovoMotorista(dados);

      if (novoMotorista) {
        // 5. Criar nova corrida com PRIORIDADE
        await this.criarCorridaPrioridade(dados, novoMotorista);
      } else {
        // 6. Se n√£o encontrou, avisar cliente
        await this.avisarSemMotoristaDisponivel(dados);
      }

      // 7. Remover do monitoramento
      this.removerMonitoramento(dados.id);

    } catch (error) {
      console.error('‚ùå Erro ao cancelar e reatribuir:', error);
    }
  }

  /**
   * Busca novo motorista excluindo o que atrasou
   */
  async buscarNovoMotorista(dados) {
    try {
      const result = await query(`
        SELECT m.*, 
          (6371 * acos(
            cos(radians($1)) * cos(radians(m.latitude)) *
            cos(radians(m.longitude) - radians($2)) +
            sin(radians($1)) * sin(radians(m.latitude))
          )) AS distancia_km
        FROM motoristas m
        WHERE m.ativo = true
          AND m.online = true
          AND m.em_corrida = false
          AND m.id != $3
          AND m.latitude IS NOT NULL
          AND m.longitude IS NOT NULL
        ORDER BY distancia_km ASC
        LIMIT 1
      `, [dados.origem_lat, dados.origem_lng, dados.motorista_id]);

      return result.rows[0] || null;
    } catch (error) {
      console.error('Erro ao buscar novo motorista:', error);
      return null;
    }
  }

  /**
   * Cria nova corrida com prioridade
   */
  async criarCorridaPrioridade(dadosAntigos, novoMotorista) {
    try {
      // Calcular tempo estimado
      const tempoEstimado = Math.ceil((novoMotorista.distancia_km || 1) * 3); // ~3 min/km

      // 1. Criar nova corrida com flag de prioridade
      const result = await query(`
        INSERT INTO corridas (
          cliente_id, motorista_id, origem_lat, origem_lng, origem_endereco,
          destino_lat, destino_lng, destino_endereco, valor, status,
          tempo_estimado, prioridade, corrida_anterior_id, tentativas_reatribuicao
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, 'aceita', $10, true, $11, $12)
        RETURNING *
      `, [
        dadosAntigos.cliente_id,
        novoMotorista.id,
        dadosAntigos.origem_lat,
        dadosAntigos.origem_lng,
        dadosAntigos.origem_endereco,
        dadosAntigos.destino_lat || null,
        dadosAntigos.destino_lng || null,
        dadosAntigos.destino_endereco || null,
        dadosAntigos.valor || 13.00,
        tempoEstimado,
        dadosAntigos.id, // Refer√™ncia √† corrida anterior
        (dadosAntigos.tentativas_reatribuicao || 0) + 1
      ]);

      const novaCorrida = result.rows[0];

      // 2. Marcar motorista como em corrida
      await query(`
        UPDATE motoristas SET em_corrida = true, atualizado_em = NOW()
        WHERE id = $1
      `, [novoMotorista.id]);

      // 3. Avisar NOVO motorista (com flag PRIORIDADE)
      const mensagemNovoMotorista = `üö® *CORRIDA PRIORIDADE*

Cliente aguardando! O motorista anterior atrasou.

üìç ${dadosAntigos.origem_endereco}
üë§ ${dadosAntigos.cliente_nome}

V√° o mais r√°pido poss√≠vel.`;

      await this.whatsapp.enviarMensagem(novoMotorista.telefone, mensagemNovoMotorista);

      // 4. Avisar cliente sobre o novo motorista
      const mensagemCliente = `üîÑ Trocamos seu motorista.

*${novoMotorista.nome}* est√° a caminho
${novoMotorista.veiculo || 'Ve√≠culo'} ${novoMotorista.cor || ''} - ${novoMotorista.placa || '---'}
${tempoEstimado} minutos`;

      await this.whatsapp.enviarMensagem(dadosAntigos.cliente_telefone, mensagemCliente);

      // 5. Adicionar nova corrida ao monitoramento
      this.adicionarMonitoramento({
        ...novaCorrida,
        cliente_telefone: dadosAntigos.cliente_telefone,
        cliente_nome: dadosAntigos.cliente_nome,
        motorista_nome: novoMotorista.nome,
        motorista_telefone: novoMotorista.telefone,
        aceito_em: new Date(),
      });

      console.log(`‚úÖ Nova corrida #${novaCorrida.id} criada com PRIORIDADE para motorista ${novoMotorista.nome}`);

    } catch (error) {
      console.error('‚ùå Erro ao criar corrida prioridade:', error);
      throw error;
    }
  }

  /**
   * Avisa cliente que n√£o tem motorista dispon√≠vel
   */
  async avisarSemMotoristaDisponivel(dados) {
    // Mensagem CURTA conforme padr√£o Rebeca
    const mensagem = `üòî N√£o encontrei outro motorista agora.

Tenta de novo em alguns minutos?`;

    try {
      await this.whatsapp.enviarMensagem(dados.cliente_telefone, mensagem);
    } catch (error) {
      console.error('Erro ao avisar cliente:', error);
    }
  }

  /**
   * Atualiza posi√ß√£o do motorista e verifica se chegou
   */
  async atualizarPosicaoMotorista(motoristaId, lat, lng) {
    for (const [corridaId, dados] of this.corridasMonitoradas) {
      if (dados.motorista_id === motoristaId) {
        // Calcular dist√¢ncia at√© o cliente
        const distancia = this.calcularDistanciaMetros(
          lat, lng,
          dados.origem_lat, dados.origem_lng
        );

        // Se est√° muito perto, considerar que chegou
        if (distancia <= CONFIG_TEMPO.DISTANCIA_CHEGADA) {
          console.log(`‚úÖ Motorista chegou na corrida #${corridaId}`);
          await this.marcarMotoristaChegou(corridaId);
        }
      }
    }
  }

  /**
   * Calcula dist√¢ncia em metros entre dois pontos
   */
  calcularDistanciaMetros(lat1, lng1, lat2, lng2) {
    const R = 6371000; // Raio da Terra em metros
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLng = (lng2 - lng1) * Math.PI / 180;
    const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
              Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
              Math.sin(dLng/2) * Math.sin(dLng/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
  }

  /**
   * Marca que motorista chegou
   */
  async marcarMotoristaChegou(corridaId) {
    try {
      await query(`
        UPDATE corridas 
        SET status = 'motorista_chegou', chegou_em = NOW()
        WHERE id = $1
      `, [corridaId]);

      const dados = this.corridasMonitoradas.get(corridaId);
      if (dados) {
        // Avisar cliente
        await this.whatsapp.enviarMensagem(
          dados.cliente_telefone,
          `üöó Seu motorista ${dados.motorista_nome} chegou! Ele est√° te esperando.`
        );
      }

      this.removerMonitoramento(corridaId);
    } catch (error) {
      console.error('Erro ao marcar chegada:', error);
    }
  }

  // ========================================
  // SISTEMA ANTI-FRAUDE INTEGRADO
  // ========================================

  /**
   * Verifica anti-fraude periodicamente e notifica ADM
   */
  async verificarAntiFraude() {
    console.log('üîç Verificando anti-fraude...');
    
    try {
      // Analisar todos os motoristas
      const analises = await this.antiFraude.analisarTodos();
      
      // Filtrar apenas alertas cr√≠ticos
      const criticos = analises.filter(a => a.score < 50);
      
      if (criticos.length > 0) {
        console.log(`‚ö†Ô∏è ${criticos.length} motoristas com alertas cr√≠ticos`);
        
        // Notificar ADM via WhatsApp
        await this.notificarADMAntiFraude(criticos);
        
        // Registrar alertas no banco
        for (const analise of criticos) {
          for (const alerta of analise.alertas) {
            await this.antiFraude.registrarAlerta(analise.motorista.id, alerta);
          }
        }
      }
    } catch (error) {
      console.error('Erro ao verificar anti-fraude:', error);
    }
  }

  /**
   * Notifica ADM sobre alertas de anti-fraude via WhatsApp (Rebeca)
   */
  async notificarADMAntiFraude(analisesCriticas) {
    if (!this.whatsapp || !this.telefoneADM) {
      console.log('‚ö†Ô∏è WhatsApp ou telefone ADM n√£o configurado');
      return;
    }

    // Limitar a 1 notifica√ß√£o por hora
    const agora = Date.now();
    if (this.ultimaNotificacaoAntiFraude && (agora - this.ultimaNotificacaoAntiFraude) < 3600000) {
      return;
    }
    this.ultimaNotificacaoAntiFraude = agora;

    // Montar mensagem
    let mensagem = `üö® *ALERTA ANTI-FRAUDE - REBECA*\n\n`;
    mensagem += `Detectei ${analisesCriticas.length} motorista(s) com comportamento suspeito:\n`;

    for (const analise of analisesCriticas.slice(0, 5)) { // M√°ximo 5 motoristas
      const mot = analise.motorista;
      mensagem += `\nüë§ *${mot.nome}* (Score: ${analise.score}/100)\n`;
      
      // Mostrar at√© 2 alertas por motorista
      for (const alerta of analise.alertas.slice(0, 2)) {
        mensagem += `   ‚îî ${alerta.titulo}\n`;
      }
      
      mensagem += `   üìä Recomenda√ß√£o: ${analise.recomendacao.acao}\n`;
    }

    mensagem += `\n_Acesse o painel ADM > Anti-Fraude para mais detalhes._`;

    try {
      await this.whatsapp.enviarMensagem(this.telefoneADM, mensagem);
      console.log('üì¢ ADM notificado sobre alertas anti-fraude');
    } catch (error) {
      console.error('Erro ao notificar ADM:', error);
    }
  }

  /**
   * Registra atraso no sistema anti-fraude
   */
  async registrarAtrasoAntiFraude(motoristaId, motoristaNome, corridaId) {
    try {
      // Registrar alerta
      await this.antiFraude.registrarAlerta(motoristaId, {
        tipo: 'atraso',
        severidade: 'amarelo',
        titulo: '‚è∞ Atraso em corrida',
        descricao: `N√£o chegou no tempo estimado na corrida #${corridaId}`,
        corrida_id: corridaId,
      });

      // Verificar se precisa notificar ADM (muitos atrasos)
      const result = await query(`
        SELECT qtd_atrasos FROM motoristas WHERE id = $1
      `, [motoristaId]);

      const atrasos = result.rows[0]?.qtd_atrasos || 0;

      // Se tiver 3+ atrasos, notificar ADM imediatamente
      if (atrasos >= 3 && this.whatsapp && this.telefoneADM) {
        const mensagem = `‚ö†Ô∏è *REBECA - Alerta de Atraso*\n\n` +
          `O motorista *${motoristaNome}* atrasou novamente!\n\n` +
          `üìä Total de atrasos: ${atrasos}\n` +
          `üî¢ Corrida: #${corridaId}\n\n` +
          `_Considere verificar no painel Anti-Fraude._`;

        await this.whatsapp.enviarMensagem(this.telefoneADM, mensagem);
        console.log(`üì¢ ADM alertado sobre atrasos de ${motoristaNome}`);
      }
    } catch (error) {
      console.error('Erro ao registrar atraso no anti-fraude:', error);
    }
  }
}

module.exports = {
  MonitoramentoCorridas,
  CONFIG_TEMPO,
  STATUS_CORRIDA,
};

